CS130 Project 2 - Design Document
=================================

Please answer all questions in this design document.  Note that the final
feedback section is optional, and you are not required to answer it if you
don't want to.

Unanswered or incompletely answered questions, or answers that don't actually
match the code/repository, will result in deductions.

Answers don't have to be deeply detailed!  We are mainly looking for an
overview or summary description of how your project works, and your team's
experiences working on this project.

Logistics (7 pts)
-----------------

L1.  [2pts] Enumerate all teammates here.
     Patrick Donohoe, Teresa Huang, Carolyn Lu

L2.  [2pts] What did each teammate focus on during this project?
     Patrick Donohoe- Fixing project 1, help on project 2 for both implementation
     and testing
     Teresa Huang- Writing majority of projcet 2 implementation code
     Carolyn Lu- Writing tests for both project 1 and 2, helped out on project 2
     implementation as well

L3.  [3pts] Approximately how many hours did each teammate spend on the project?
     Patrick Donohoe- 25 hours
     Teresa Huang- 25 hours
     Carolyn Lu- 25 hours

Spreadsheet Engine Design (10 pts)
----------------------------------

D1.  [3pts] Briefly describe how your workbook-loading code operates.  Does
     it do anything sophisticated to optimize the performance of loading a
     workbook, such as deferring cell-value update calculations, or analyzing
     the graph of cell dependencies?
     The workbook-loading code has a relatively simple approach to it. It
     populates each sheet and the contents of each cell in the sheet as it
     reads through the json file. Therefore, it calculates updates exactly how
     a regular workbook with populated values would and calculates a cell's 
     value immediately after its contents are set, so it does not implement
     anything sophisticated to optimize performance. We did not focus on
     improving performance this project, but for the next project when we do
     need to start improving performance, we will reassess this approach of
     loading workbooks.


D2.  [3pts] Sheet-level operations like copying a sheet, deleting a sheet,
     renaming a sheet, or even creating a new sheet, can cause cell values
     to be updated.  How does your workbook identify such cells and ensure
     that they are updated properly?
     We have set up a bidirectional graph of cell dependencies that is
     independent from each sheets designnated sheet object. The dictionaries
     that contain the edges going in each direction- from cell to dependent
     cell and from cell to cell it inherits from- are both sorted by sheet.
     When we copy or create a new sheet, we will loop though all the cells in
     the graph that have cells dependent on them in the new sheet, and call
     our update_workbook on them. The update_workbook topographically updates
     all cells that are dependent on a given cell. 

     When we delete a sheet, call update_workbook on all cells dependent on
     the sheet we are deleting after we delete the sheet.

     In rename_sheet, we updated the name of the sheet in our bidirectional
     graph, and then call update_workbook on each cell with dependent cells
     in the new sheet. When updating our graph we use the fact it is
     bidirectional to efficiently update the sheetname of all the 
     cells in the graph.

D3.  [4pts] When renaming a sheet, cells with formulas that explicitly
     reference the renamed sheet must be updated with the new sheet name.
     Give an overview of how your implementation updates these formulas.

     We updated cell formula's by using our bidirectional graph to determine
     which cells formulas we needed to update, and then we sent this cell, the
     old sheet name, and new sheet name to a function in our sheet class
     that changes the sheet reference in a given cells contents, and also
     hanldes all of the edge cases surrounding updating a sheet name in a 
     cells contents. 


Spreadsheet Engine Code Review (17 pts)
---------------------------------------

R1.  [2pts] What part of your spreadsheet code-base did your team select to
     review?  Why did you select this portion of your code to review?
     We reviewed our process for setting and updating cells. We chose this
     portion of code because we noticed in our performance tests that we
     were struggling a little bit in this area, so we wanted to put our
     heads together to see how to improve this area.

R2.  [2pts] Approximately how much code did your team review?  How much time did
     the meeting take?
     We reviewed between 200-300 lines of code, all related to setting and
     updating cells. Because our review also included brainstorming ideas
     to improve the code, the meeting took slightly over an hour and a half.

R3.  [6pts] Include the list of action-items that were generated by the
     code-review here.
     - Streamline set cell contents to stop sending our code through many
       different functions to all end up in the same place
     - Clarify the purpose of each function related to setting the value of
       each cell, to enable us to have a clearer sense of direction within our
       codebase and make our code easier to debug
         - Add comments wherever there is unclear code
         - Clean up existing code
         - Add more descriptive variable names
     - Improve our method for notification of updating cells by taking
       advantage of a more streamlined approach throughout the codebase that
       defines clear roles for each function
     - Once a cell is no longer part of a cycle, remove it from the cycle 
       graph

     Unrelated to the code-review but still on our action list:
     - See if it is possible to refactor repetitive code, especially in the
       lark/formula evaluator portion of the code. Specifically, string error
       handling and removing trailing zeros has repetitive code in both
       workbook.py and lark_impl.py, both of which are currently necessary to
       our current implementation.

R4.  [3pts] Have you been able to address the action items identified?  If not,
     what is your plan and timeframe to do so?
     We have not been able to address these issues yet, as we did our code
     review after we finished implementing the new features. We plan to work on
     refactoring our set cell contents method prior to the conclusion of this
     weekend.

R5.  [4pts] Reflect on whether the code review helped with knowledge-sharing in
     the team.  Do teammates feel more confident maintaining the code that was
     reviewed, and/or extending the code in the future?
     Code review was extremely useful because it gave us an opportunity to
     analyze our code in a structured setting, and set clear priorities for where
     we can improve our code with the hope of improving the ease of use of our
     code in the future. It also helps keep all team members accountable and
     helps the code writer think about whether their code is readable to others.
     It was also a good opportunity for all of us to come together and
     understand each other's code, which we did not really do for the previous 
     project. Therefore, it kept all of us on the same page for this project.

Performance Analysis (16 pts)
-----------------------------

In this project you must measure and analyze the performance of two central
areas of your spreadsheet engine.  Using pair programming, construct some
performance tests to exercise these aspects of your engine, and use a profiler
to identify where your program is spending the bulk of its time.

A1.  [4pts] Briefly enumerate the performance tests you created to exercise
     your implementation, along with the teammates that collaborated to
     implement each of them.
     We went with the example performance tests described in the spec, of
     which included a test that requires updates to propagate through
     long chains of cell references and also one that requires many updates
     but with shallower chains and more references. For performance testing
     related to cycle-detection, we included three tests: one testing one 
     very large cycle with many cells, one with many small cycles with less 
     cells in each cycle, and another with one cell involved in many different
     cycles. For all of these, we repeatedly made and broke cycles to fully
     stress our cycle-detection code.


A2.  [2pts] What profiler did you choose to run your performance tests with?
     Why?  Give an example of how to invoke one of your tests with the profiler.

     We chose to use cProfile mainly because of the output that it gave in
     comparison to the other two sampling profilers. Although the sampling
     profilers take less time to run, we felt that the information provided
     by cProfile was easier to access and understand. To invoke one of our tests
     with the profiler, you simply need to run "python3 -m unittest 
     tests.performance.TestPerformance.{specific_test}." Each test already has
     a profiler included inside, so there is no need to invoke it again
     through the command line. To start the profiler inside a test itself, you
     first need to create a cProfile.Profile(), enable it, run any code you 
     want to analyze, and then disable it.

A3.  [6pts] What are ~3 of the most significant hot-spots you identified in your
     performance testing?  Did you expect these hot-spots, or were they
     surprising to you?
     We identified our cycle detection code to take the most time in our
     performance tests. In specific, all three of those tests (one testing one 
     very large cycle with many cells, one with many small cycles with less 
     cells in each cycle, and one cell involved in many different cycles)
     took significantly more time than the long chains and references
     tests. However, we realized that the time the performance tests take also
     heavily depends on the workbook and sheets/cells we have set up, and greatly
     varies from test to test. So, we decided to focus on specific methods
     instead. Across all five tests, our set_cell_contents always took the most
     time. The next two methods that took the most time were update_workbook
     and calculate_contents. This was not surprising to us either, as 
     set_cell_contents combines many different heavy aspects of our code,
     such as DFS, update_workbook, and calculating contents. update_workbook 
     also calls our iterative Tarjan's algorithm implementation, which we also
     knew would take more time than others. calculate_contents was surprising,
     however looking back, this also makes sense because all of the formula
     evaluation takes place here.


A4.  [4pts] Reflect on the experience of pair-programming as you constructed
     these tests.  What went well with it?  What would you like to try to do
     better in the future?
     We have been utilizing pair-programming substantially throughout our
     development process, and have always found it to be incredibly helpful. 
     Especially with tests, it's often hard to think of edge cases and potential
     cases that could cause our code to break. It's always nice to have a fresh
     pair of eyes think it through with you to minimize the number of edge cases
     missed. In the future, we would like to pair-program on tests more. We
     often only pair-program for the actual implementation, but we have found
     that pair-programming for tests is also incredibly helpful.


Section F:  CS130 Project 2 Feedback [OPTIONAL]
-----------------------------------------------

These questions are OPTIONAL, and you do not need to answer them.  Your grade
will not be affected by answering or not answering them.  Also, your grade will
not be affected by negative feedback - we want to know what went poorly so that
we can improve future versions of the course.

F1.  What parts of the assignment did you find highly enjoyable?  Conversely,
     what parts of the assignment did you find unenjoyable?


F2.  What parts of the assignment helped you learn more about software
     engineering best-practices, or other useful development skills?
     What parts were not helpful in learning these skills?


F3.  Were there any parts of the assignment that seemed _unnecessarily_ tedious?
     (Some parts of software development are always tedious, of course.)


F4.  Do you have any feedback and/or constructive criticism about how this
     project can be made better in future iterations of CS130?